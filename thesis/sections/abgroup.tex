\chapter{Abelian Group (Addition)}
\label{ch:abgroup}

\section{Addition Operation}
To define addition, we will use our iterator. For this, we will need an equivalence, in this simpler case we will first define an isomorphism, then convert that to an equivalence.
This isomorphism will be based on 'succ' being the function, its inverse function will be 'pred', and to prove that using 'succ' then 'pred', and using 'pred' then 'succ' results in the same value, we will use our 'section' and 'retraction' constructors.

We can then convert this isomorphism to an equivalence with the 'isoToEquiv' builtin function. Equivalence is an ordered pair, where the first parameter will be our 'succ' function, and the second will contain the proofs we previously mentioned.

Using the iterator we defined earlier, we can first supply the 'idfun' (identity function) version of ℤₕ, this will convert ℤₕ to a 'ℤₕ → ℤₕ' type. This will be beneficial since we have 2 implicit parameters, and we will want to move the constructors ('succ' and 'pred') from the left parameter to the right one. Next, we will post-compose our defined 'succEquiv'. This will change our 'ℤₕ ≃ ℤₕ' to a '(ℤₕ → ℤₕ) ≃ (ℤₕ → ℤₕ)' (more specifically (C → ℤₕ) ≃ (C → ℤₕ)), this is to match the type needed by our iterator. We implicitly supply the left and right parameters to this. (More specifically, we will first supply our left parameter, for this our iterator will return ℤₕ → ℤₕ, and we will supply our right parameter to this - see the comment in the code for this).

This will have the desired effect that we wanted: from our left parameter the 'succ' and 'pred' constructors will be placed on the beginning of the right parameter, which is otherwise known as addition.

As we already established when defining our iterator, we won't have to deal with our 1- and 2-dimensional construcotrs and their boundaries, as it is handled by our iterator.

\begin{minted}{agda}
succIso : Iso ℤₕ ℤₕ
succIso .Iso.fun      = succ
succIso .Iso.inv      = pred
succIso .Iso.rightInv = ret
succIso .Iso.leftInv  = sec

succEquiv : ℤₕ ≃ ℤₕ
succEquiv = isoToEquiv succIso

infixl 6 _+_
_+_ : ℤₕ → ℤₕ → ℤₕ
_+_ = ℤₕ-ite (idfun ℤₕ) (postCompEquiv succEquiv)
-- m + n = (ℤₕ-ite (idfun ℤₕ) (postCompEquiv succEquiv) m) n
\end{minted}

Definitionally, the following hold true for the addition operation in Agda:
\begin{minted}{agda}
zero   + n ≡ n
succ m + n ≡ succ (m + n)
pred m + n ≡ pred (m + n)
\end{minted}
Note that the symmetric version of these also hold true.

Alternatively, we could define addition by pattern matching on the second parameter, this would mean we manually have to satisfy the boundaries in the 1- and 2-dimensional constructor cases, however, here they would be fairly trivial:
% !!BOUNDARY!!
\begin{minted}{agda}
_+_ : ℤₕ → ℤₕ → ℤₕ
zero      + b = b
succ a    + b = succ (a + b)
pred a    + b = pred (a + b)
sec a i   + b = sec (a + b) i
ret a i   + b = ret (a + b) i
coh a i j + b = coh (a + b) i j
\end{minted}

\section{Associativity}
\begin{theorem}
  Addition is associative: ∀ m, n, o ∈ ℤ: m + (n + o) = (m + n) + o
\end{theorem}

\begin{proof}
  We will use our induction property to prove this theorem. For the first case, which states that this is indeed a property, we will use the 'isProp' (specifically the one which takes 2 parameters) and our set property, thankfully cubical Agda can infer the parameters for this. In all future proofs we will rely on Agda inferring these parameters.

  For the base case (m = 0) : 0 + (n + o) = (n + o) = (0 + n) + o is a reflection.

  For the succ case: (succ m) + (n + o) = ((succ m) + n) + o, note that since we are using the induction property, we will have the original m + (n + o) = (m + n) + o equality, where we are free to change the parameters of 'n' and 'o' as we please. Applying succ to the original equality will result in succ (m + (n + o)) = succ (m + n + o), thanks to the fact that succ (m + n) = succ m + n holds true definitionally, where we can supply 'm' to the m parameter, and 'n + o' to the n parameter. We will also have to note that addition is parenthesized from the left, so succ m + n + o = (succ m + n) + o is also definitionally true.

  For the pred case: (pred m) + (n + o) = ((pred m) + n) + o, similarly to the succ case, it is enough to apply pred to the original equality. We will once again note that pred (m + n) = pred m + n is definitionally true, and the fact that addition is parenthesized from the left.
\end{proof}

\begin{listing}[H]
\begin{minted}{agda}
+-assoc : ∀ m n o → m + (n + o) ≡ (m + n) + o
+-assoc = ℤₕ-ind-prop
  (λ _ → isPropΠ2 λ _ _ → isSetℤₕ _ _)
  (λ n o → refl)
  (λ m p n o → cong succ (p n o))
  (λ m p n o → cong pred (p n o))
\end{minted}
\caption{Agda proof of addition being associative}
\end{listing}

\section{Identity Element}
\begin{minted}[fontsize=\small]{agda}
+-idˡ : ∀ z → zero + z ≡ z
+-idˡ z = refl

+-zero : ∀ z → z + zero ≡ z
+-zero = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong succ p)
  (λ z p → cong pred p)

+-idʳ : ∀ z → z + zero ≡ z
+-idʳ = +-zero
\end{minted}

\section{Negation and Subtraction}
\begin{minted}[fontsize=\small]{agda}
-_ : ℤₕ → ℤₕ
-_ = ℤₕ-ite zero (invEquiv succEquiv)

_-_ : ℤₕ → ℤₕ → ℤₕ
m - n = m + (- n)
\end{minted}

\section{Inverse Element}
\begin{minted}[fontsize=\small]{agda}
+-succ : ∀ m n → m + succ n ≡ succ (m + n)
+-succ = ℤₕ-ind-prop
  (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
  (λ m → refl)
  (λ m p n → cong succ (p n))
  (λ m p n → cong pred (p n) ∙ sec (m + n) ∙ sym (ret (m + n)))

+-pred : ∀ m n → m + pred n ≡ pred (m + n)
+-pred = ℤₕ-ind-prop
  (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
  (λ m → refl)
  (λ m p n → cong succ (p n) ∙ ret (m + n) ∙ sym (sec (m + n)))
  (λ m p n → cong pred (p n))

+-invˡ : ∀ z → (- z) + z ≡ zero
+-invˡ = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong pred (+-succ (- z) z) ∙ sec _ ∙ p)
  (λ z p → cong succ (+-pred (- z) z) ∙ ret _ ∙ p)

+-invʳ : ∀ z → z + (- z) ≡ zero
+-invʳ = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong succ (+-pred z (- z)) ∙ ret _ ∙ p)
  (λ z p → cong pred (+-succ z (- z)) ∙ sec _ ∙ p)
\end{minted}

\section{Commutativity}
\begin{minted}[fontsize=\small]{agda}
+-comm : ∀ m n → m + n ≡ n + m
+-comm m n = +-comm' n m
  where
  +-comm' : ∀ n m → m + n ≡ n + m
  +-comm' = ℤₕ-ind-prop
    (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
    +-zero
    (λ n p m → +-succ m n ∙ cong succ (p m))
    (λ n p m → +-pred m n ∙ cong pred (p m))
\end{minted}
