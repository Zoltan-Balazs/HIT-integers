\chapter{Abelian Group (Addition)}
\label{ch:abgroup}

\section{Addition Operation}
To define addition, we will use our iterator. For this, we will need an equivalence, in this simpler case we will first define an isomorphism, then convert that to an equivalence.
This isomorphism will be based on 'succ' being the function, its inverse function will be 'pred', and to prove that using 'succ' then 'pred', and using 'pred' then 'succ' results in the same value, we will use our 'section' and 'retraction' constructors.

We can then convert this isomorphism to an equivalence with the 'isoToEquiv' builtin function. Equivalence is an ordered pair, where the first parameter will be our 'succ' function, and the second will contain the proofs we previously mentioned.

Using the iterator we defined earlier, we can first supply the 'idfun' (identity function) version of ℤₕ, this will convert ℤₕ to a 'ℤₕ → ℤₕ' type. This will be beneficial since we have 2 implicit parameters, and we will want to move the constructors ('succ' and 'pred') from the left parameter to the right one. Next, we will post-compose our defined 'succEquiv'. This will change our 'ℤₕ ≃ ℤₕ' to a '(ℤₕ → ℤₕ) ≃ (ℤₕ → ℤₕ)' (more specifically (C → ℤₕ) ≃ (C → ℤₕ)), this is to match the type needed by our iterator. We implicitly supply the left and right parameters to this. (More specifically, we will first supply our left parameter, for this our iterator will return ℤₕ → ℤₕ, and we will supply our right parameter to this - see the comment in the code for this).

This will have the desired effect that we wanted: from our left parameter the 'succ' and 'pred' constructors will be placed on the beginning of the right parameter, which is otherwise known as addition.

As we already established when defining our iterator, we won't have to deal with our 1- and 2-dimensional construcotrs and their boundaries, as it is handled by our iterator.

\begin{minted}{agda}
succIso : Iso ℤₕ ℤₕ
succIso .Iso.fun      = succ
succIso .Iso.inv      = pred
succIso .Iso.rightInv = ret
succIso .Iso.leftInv  = sec

succEquiv : ℤₕ ≃ ℤₕ
succEquiv = isoToEquiv succIso

infixl 6 _+_
_+_ : ℤₕ → ℤₕ → ℤₕ
_+_ = ℤₕ-ite (idfun ℤₕ) (postCompEquiv succEquiv)
-- m + n = (ℤₕ-ite (idfun ℤₕ) (postCompEquiv succEquiv) m) n
\end{minted}

Definitionally, the following hold true for the addition operation in Agda:
\begin{minted}{agda}
zero   + n ≡ n
succ m + n ≡ succ (m + n)
pred m + n ≡ pred (m + n)
\end{minted}
Note that the symmetric version of these also hold true.

Alternatively, we could define addition by pattern matching on the second parameter, this would mean we manually have to satisfy the boundaries in the 1- and 2-dimensional constructor cases, however, here they would be fairly trivial:
% !!BOUNDARY!!
\begin{minted}{agda}
_+_ : ℤₕ → ℤₕ → ℤₕ
zero      + b = b
succ a    + b = succ (a + b)
pred a    + b = pred (a + b)
sec a i   + b = sec (a + b) i
ret a i   + b = ret (a + b) i
coh a i j + b = coh (a + b) i j
\end{minted}

\section{Associativity}
\begin{minted}[fontsize=\small]{agda}
+-assoc : ∀ m n o → m + (n + o) ≡ (m + n) + o
+-assoc = ℤₕ-ind-prop
  (λ _ → isPropΠ2 λ _ _ → isSetℤₕ _ _)
  (λ n o → refl)
  (λ m p n o → cong succ (p n o))
  (λ m p n o → cong pred (p n o))
\end{minted}

\section{Identity Element}
\begin{minted}[fontsize=\small]{agda}
+-idˡ : ∀ z → zero + z ≡ z
+-idˡ z = refl

+-zero : ∀ z → z + zero ≡ z
+-zero = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong succ p)
  (λ z p → cong pred p)

+-idʳ : ∀ z → z + zero ≡ z
+-idʳ = +-zero
\end{minted}

\section{Negation and Subtraction}
\begin{minted}[fontsize=\small]{agda}
-_ : ℤₕ → ℤₕ
-_ = ℤₕ-ite zero (invEquiv succEquiv)

_-_ : ℤₕ → ℤₕ → ℤₕ
m - n = m + (- n)
\end{minted}

\section{Inverse Element}
\begin{minted}[fontsize=\small]{agda}
+-succ : ∀ m n → m + succ n ≡ succ (m + n)
+-succ = ℤₕ-ind-prop
  (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
  (λ m → refl)
  (λ m p n → cong succ (p n))
  (λ m p n → cong pred (p n) ∙ sec (m + n) ∙ sym (ret (m + n)))

+-pred : ∀ m n → m + pred n ≡ pred (m + n)
+-pred = ℤₕ-ind-prop
  (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
  (λ m → refl)
  (λ m p n → cong succ (p n) ∙ ret (m + n) ∙ sym (sec (m + n)))
  (λ m p n → cong pred (p n))

+-invˡ : ∀ z → (- z) + z ≡ zero
+-invˡ = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong pred (+-succ (- z) z) ∙ sec _ ∙ p)
  (λ z p → cong succ (+-pred (- z) z) ∙ ret _ ∙ p)

+-invʳ : ∀ z → z + (- z) ≡ zero
+-invʳ = ℤₕ-ind-prop
  (λ _ → isSetℤₕ _ _)
  refl
  (λ z p → cong succ (+-pred z (- z)) ∙ ret _ ∙ p)
  (λ z p → cong pred (+-succ z (- z)) ∙ sec _ ∙ p)
\end{minted}

\section{Commutativity}
\begin{minted}[fontsize=\small]{agda}
+-comm : ∀ m n → m + n ≡ n + m
+-comm m n = +-comm' n m
  where
  +-comm' : ∀ n m → m + n ≡ n + m
  +-comm' = ℤₕ-ind-prop
    (λ _ → isPropΠ λ _ → isSetℤₕ _ _)
    +-zero
    (λ n p m → +-succ m n ∙ cong succ (p m))
    (λ n p m → +-pred m n ∙ cong pred (p m))
\end{minted}
